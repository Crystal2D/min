class AnimationFrame{#t=[];#n=[];index=0;get actions(){return[...this.#t]}set actions(t){this.#t=[...t],this.#n=[];for(let t=0;t<this.#t.length;t++){const n=CrystalEngine.Inner.GetClassOfType(this.actions[t].component,0),s=[...n.args,...n.keys].find((n=>n.name===this.actions[t].property));this.#n.push({component:this.#t[t].component,propData:s,value:this.#t[t].value})}}async Invoke(t){for(let n=0;n<this.#n.length;n++){const s=this.#n[n],a=t.GetComponent(s.component);await SceneManager.EvalProperty(s.propData,s.value,a)}}}class AnimationClip{loop=!0;framerate=1;duration=1;frames=[];async InvokeFrames(e,n,i){const a=this.frames.filter((i=>i.index>e&&i.index<=n)).sort(((e,n)=>e.index-n.index));for(let e=0;e<a.length;e++)await a[e].Invoke(i)}async InvokeFramesReverse(e,n,i){const a=this.frames.filter((i=>i.index<e&&i.index>=n)).sort(((e,n)=>n.index-e.index));for(let e=0;e<a.length;e++)await a[e].Invoke(i)}Unload(){}}class AnimatorNode{transitions=[];get hasStarted(){return!1}get hasEnded(){return!1}get time(){return 0}get duration(){return 0}Update(t){}Start(){}End(){}Duplicate(){}}class AnimatorMotion extends AnimatorNode{#t=!1;#e=!1;#i=0;#s=-1;speed=1;name="animation";animation=null;get hasStarted(){return this.#t}get hasEnded(){return this.#e}get framerate(){return this.animation.framerate}get time(){return Math.min(this.#i,this.duration)}get frameTime(){return Math.min(this.#s,this.frameDuration)}get frameDuration(){return this.animation.duration}get duration(){return this.frameDuration/this.framerate}get normalizedTime(){return this.reversed?(this.duration-this.#i)/this.duration:this.time/this.duration}get reversed(){return this.speed<0}set reversed(t){this.speed=Math.abs(this.speed)*(t?-1:1)}Update(t){if(this.#t||this.Start(),this.#e||0===this.speed||0===this.animation.frames.length)return;const e=Time.deltaTime*this.speed;this.#i+=e;const i=Math.floor(this.#i*this.animation.framerate);(this.reversed&&i<0||i>=this.frameDuration)&&this.End(),this.#s!==i&&(this.speed>0?this.animation.InvokeFrames(this.#s,i,t):this.animation.InvokeFramesReverse(this.#s,i,t),this.#s=i),this.#e}Start(){this.#t=!0,this.#e=!1,this.#i=this.reversed?this.duration:0,this.#s=this.reversed?this.frameDuration:-1}End(){this.#e=!0,this.animation.loop&&(this.#t=!1)}Duplicate(){const t=new AnimatorMotion;return t.transitions=this.transitions,t.speed=this.speed,t.name=this.name,t.reversed=this.reversed,t.animation=this.animation,t}}class AnimatorConditionMode{static get If(){return 0}static get IfNot(){return 1}static get Greater(){return 2}static get Less(){return 3}static get Equals(){return 4}static get NotEquals(){return 5}}class AnimatorCondition{threshold=0;mode=0;parameter=""}class AnimatorControllerParameterType{static get Bool(){return 0}static get Trigger(){return 1}static get Number(){return 2}}class AnimatorControllerParameter{defaultBool=!1;lastTriggerState=!1;defaultNumber=0;type=0;value=null;Duplicate(){const t=new AnimatorControllerParameter;return t.name=this.name,t.defaultBool=this.defaultBool,t.lastTriggerState=this.lastTriggerState,t.defaultNumber=this.defaultNumber,t.type=this.type,t.value=this.value,t}}class AnimatorTransition{isExit=!0;exitTime=1;nextNode="";conditions=[]}class AnimatorController{#t=!1;nodes=[];parameters=[];currentNode=null;currentTransition=null;Update(t){if(this.#t||(this.#t=!0,this.currentNode=this.nodes[0].Duplicate(),this.currentNode.Start(),this.currentTransition=this.currentNode.transitions.find((t=>t.isExit))),this.currentNode.Update(t),null==this.currentTransition){const t=this.currentNode.transitions;for(let e=0;e<t.length;e++){const r=t[e];let n=!0;for(let t=0;t<r.conditions.length;t++){const e=r.conditions[t],o=this.parameters.find((t=>t.name===e.parameter));if(null==o.value&&(o.type===AnimatorControllerParameterType.Bool?o.value=o.defaultBool:o.type===AnimatorControllerParameterType.Number&&(o.value=o.defaultNumber)),o.type===AnimatorControllerParameterType.Bool){const t=+o.value===e.threshold;e.mode!==AnimatorConditionMode.Equals||t?e.mode===AnimatorConditionMode.NotEquals&&t&&(n=!1):n=!1}if(o.type===AnimatorControllerParameterType.Trigger){const t=+o.value===e.threshold;e.mode!==AnimatorConditionMode.If||t?e.mode===AnimatorConditionMode.IfNot&&t&&(n=!1):n=!1}o.type===AnimatorControllerParameterType.Number&&(e.mode===AnimatorConditionMode.Greater&&o.value<=e.threshold||e.mode===AnimatorConditionMode.Less&&o.value>=e.threshold||e.mode===AnimatorConditionMode.Equals&&o.value!==e.threshold||e.mode===AnimatorConditionMode.NotEquals&&o.value===e.threshold)&&(n=!1)}if(n){this.currentTransition=r;break}}}null!=this.currentTransition&&(this.currentNode.animation.loop&&this.currentTransition.isExit||!(this.currentNode.normalizedTime>=this.currentTransition.exitTime)||(this.currentNode.End(),this.currentNode=this.nodes.find((t=>t.name===this.currentTransition.nextNode)).Duplicate(),this.currentNode.Start(),this.currentTransition=this.currentNode.transitions.find((t=>t.hasExitTime))))}Unload(){}Duplicate(){const t=new AnimatorController;return t.parameters=this.parameters.map((t=>t.Duplicate())),t.nodes=this.nodes,t.currentNode=this.currentNode?.Duplicate(),t.currentTransition=this.currentTransition,t}}class Animator extends GameBehavior{controller=null;Update(){this.controller?.Update(this.gameObject)}LateUpdate(){if(null==this.controller)return;const e=this.controller.parameters.filter((e=>e.type===AnimatorControllerParameterType.Trigger));for(let r=0;r<e.length;r++)e[r].value&&e[r].value===e[r].lastTriggerState&&(e[r].value=!1),e[r].lastTriggerState=e[r].value}#e(e,r){return this.controller.parameters.find((t=>t.name===e&&t.type===r))}GetBool(e){return this.#e(e,AnimatorControllerParameterType.Bool).value}GetNumber(e){return this.#e(e,AnimatorControllerParameterType.Number).value}SetBool(e,r){this.#e(e,AnimatorControllerParameterType.Bool).value=r}SetNumber(e,r){this.#e(e,AnimatorControllerParameterType.Number).value=r}SetTrigger(e){this.#e(e,AnimatorControllerParameterType.Trigger).value=!0}Duplicate(){const e=new Animator;return e.controller=this.controller.Duplicate(),e}}