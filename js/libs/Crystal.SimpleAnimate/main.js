class AnimationClip{loop=!0;interval=.5;sprites=[]}class AnimatorNodeBase{transitions=[];get currentTime(){return 0}get duration(){return 0}}class AnimatorNode extends AnimatorNodeBase{#t=!1;#e=!1;#i=0;#s=0;#r=0;speed=1;name="animation";animation=null;get hasStarted(){return this.#t}get hasEnded(){return this.#e}get currentTime(){return Math.min(this.#s,this.duration)}get duration(){return this.animation.sprites.length*this.animation.interval}get normalizedTime(){return this.currentTime/this.duration}get reversed(){return this.speed<0}set reversed(t){this.speed=Math.abs(this.speed)*(t?-1:1)}Update(t){if(!this.#e&&0!==this.speed&&0!==this.animation.sprites.length){if(this.#i>0){const t=Time.deltaTime*Math.abs(this.speed);return this.#i-=t,void(this.#s+=t)}if((this.reversed&&this.#r<0||this.#r>=this.animation.sprites.length)&&this.End(),this.#t){if(this.#e)return}else this.Start();t.sprite=this.animation.sprites[this.#r],this.#r+=this.reversed?-1:1,this.#i=this.animation.interval}}Start(){this.#t=!0,this.#e=!1,this.#s=0,this.#r=this.reversed?this.animation.sprites.length-1:0}End(){this.#e=!0,this.animation.loop&&(this.#t=!1)}}class AnimatorTransition{exitTime=1;nextNode=1}class AnimatorContoller{#e=0;nodes=[];renderer=null;Update(){const e=this.nodes[this.#e];e.Update(this.renderer),!e.animation.loop&&e.normalizedTime>=e.transitions[0].exitTime&&(this.#e=e.transitions[0].nextNode,this.nodes[this.#e].Start())}}class Animator extends GameBehavior{#t=null;#n=null;get controller(){return this.#n}set controller(t){this.#n=t,this.#n.renderer=this.#t}Start(){this.#t=this.GetComponent("SpriteRenderer"),this.controller=new AnimatorContoller;const t=Resources.Find("animations/characters/yoki");t.loop=!1;const n=new AnimatorNode;n.animation=t,n.speed=-.5,n.transitions=[new AnimatorTransition];const e=Resources.Find("animations/characters/spin"),r=new AnimatorNode;r.animation=e,r.speed=10,r.transitions=[new AnimatorTransition],r.transitions[0].nextNode=0,this.#n.nodes.push(n,r)}Update(){this.#n?.Update()}}