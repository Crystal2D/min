class TilePalette{static#t=!1;static#e=[];static#s=[];name="";sprites=[];static get isLoaded(){return this.#t}static async Set(){if(this.#t)return;const t=await FetchFile("data/tilepalettes.json");this.#e=await t.json(),this.#t=!0}static async Load(t){const e=this.#e.find((e=>e.name===t)),s=new TilePalette;s.name=t;const a=[],unloadCall=()=>{for(let t=0;t<a.length;t++)a[t].onUnload.Remove(unloadCall);this.Unload(t)};for(let t=0;t<e.textures.length;t++){if(0===e.textures.sprites?.length)continue;const i=Resources.Find(e.textures[t].src);i.onUnload.Add(unloadCall),a.push(i),s.sprites.push(...e.textures[t].sprites.map((t=>{const e=null!=t.name?i.sprites.find((e=>e.name===t.name)):i.sprites[t.index??0];return{id:t.id,sprite:e.Duplicate()}})))}this.#s.push(s)}static Unload(t){const e=this.Find(t);this.#s.splice(this.#s.indexOf(e),1)}static UnloadAll(){this.#s=[]}static Find(t){return this.#s.find((e=>e.name===t))}}TilePalette.Set();class Tile{palette="";spriteID=0;position=Vector2.zero;sprite=null;constructor(t,e,i){this.palette=t,this.spriteID=e??0,this.position=i??Vector2.zero}Duplicate(){return new Tile(this.palette,this.spriteID,this.position)}}class Tilemap extends Renderer{#t=!1;#e=!0;#i=!0;#r=[];#s=[];#l=Vector2.zero;#a=new Bounds(new Vector2(NaN,NaN));#o=Matrix3x3.identity;#h=null;#n=null;#d=null;#u=null;mergeResolution=16;grid=null;get meshChanged(){return this.#e}get bounds(){return new Bounds(this.#a.center,this.#a.size)}get localToWorldMatrix(){return Matrix3x3.Multiply(this.grid.transform.localToWorldMatrix,this.#o)}get mergedRendering(){return null!=this.#u}#c=class{colorsUpdated=!1;arraysUpdated=!1;currentIndex=0;uMatrixID=0;geometryBufferID=0;textureBufferID=0;colorBufferID=0;aVertexPosID=0;aTexturePosID=0;aColorID=0;tiles=[];vertexArray=[];textureArray=[];color=[];colorArray=[];indexes=[];trisCounts=[];scaler=Vector2.zero;texture=null;material=null;parent=null;#x(t){const e=t.sprite.vertices,i=e[0],r=t.sprite.triangles,s=Vector2.Divide(Vector2.Subtract(this.parent.grid.CellToWorldUnscaled(new Vector2(t.position.x,-t.position.y)),Vector2.Divide(Vector2.Scale(new Vector2(t.sprite.rect.width,t.sprite.rect.height),t.sprite.pivot),this.texture.pixelPerUnit)),this.scaler);let l=[],a=[];for(let t=0;t<r.length;t++){const o=e[r[t]],h=2*t;l[h]=o.x-i.x+s.x,l[h+1]=o.y-i.y+s.y,a[h]=o.x,a[h+1]=o.y}return{vertexArray:l,textureArray:a,trisCount:r.length}}SetMaterial(t){this.material?.Unload(),this.material=t.Duplicate(),this.material.SetSampler2D("uSampler",0),this.uMatrixID=this.material.GetPropertyNameID("uMatrix"),this.geometryBufferID=this.material.AddBuffer("geometry",null,2),this.textureBufferID=this.material.AddBuffer("texture",null,2),this.colorBufferID=this.material.AddBuffer("color",null,4),this.aVertexPosID=this.material.GetAttributeNameID("aVertexPos"),this.aTexturePosID=this.material.GetAttributeNameID("aTexturePos"),this.aColorID=this.material.GetAttributeNameID("aColor")}SetColors(t){this.color=t,this.colorArray=[];for(let e=0;e<this.tiles.length;e++)this.colorArray.push(...t,...t,...t,...t,...t,...t);this.colorsUpdated=!0}UpdateMesh(){const t=this.texture.pixelPerUnit,e=this.texture.width,i=this.texture.height,r=e/t,s=i/t;this.scaler=Vector2.Scale(e>i?new Vector2(1,i/e):new Vector2(e/i,1),e>i?r:s),this.currentIndex=0,this.vertexArray=[],this.textureArray=[],this.trisCounts=[],this.indexes=[];for(let t=0;t<this.tiles.length;t++){const e=this.#x(this.tiles[t]);this.vertexArray.push(...e.vertexArray),this.textureArray.push(...e.textureArray),this.trisCounts.push(e.trisCount-1),this.indexes.push(this.currentIndex),this.currentIndex+=e.trisCount}this.arraysUpdated=!0,this.SetColors(this.color)}Add(t){this.tiles.push(t);const e=this.#x(t);this.vertexArray.push(...e.vertexArray),this.textureArray.push(...e.textureArray),this.trisCounts.push(e.trisCount-1),this.indexes.push(this.currentIndex),this.currentIndex+=e.trisCount,this.colorArray.push(...this.color,...this.color,...this.color,...this.color,...this.color,...this.color),this.arraysUpdated=!0,this.colorsUpdated=!0}Remove(t){const e=this.tiles.indexOf(t),i=12*e;this.tiles.splice(e,1),this.vertexArray.splice(i,12),this.textureArray.splice(i,12),this.trisCounts.splice(e,1),this.indexes.pop(),this.currentIndex-=t.sprite.triangles.length,this.colorArray.splice(0,24),this.arraysUpdated=!0,this.colorsUpdated=!0}};constructor(t){super(t),this.Reload()}#m(){this.#h=this.color.Duplicate();const t=[this.color.r,this.color.g,this.color.b,this.color.a];if(null==this.#u)for(let e=0;e<this.#s.length;e++)this.#s[e].SetColors(t);else this.material.SetBuffer(this.colorBufferID,[...t,...t,...t,...t,...t,...t])}#p(t){t.colorsUpdated&&(t.material.SetBuffer(t.colorBufferID,t.colorArray),t.colorsUpdated=!1),t.arraysUpdated&&(t.material.SetBuffer(t.geometryBufferID,t.vertexArray),t.material.SetBuffer(t.textureBufferID,t.textureArray),t.arraysUpdated=!1);const e=Matrix3x3.Multiply(this.renderMatrix,Matrix3x3.Scale(t.scaler));t.material.SetMatrix(t.uMatrixID,e.matrix[0][0],e.matrix[0][1],e.matrix[0][2],e.matrix[1][0],e.matrix[1][1],e.matrix[1][2],e.matrix[2][0],e.matrix[2][1],e.matrix[2][2]),t.material.SetAttribute(t.aVertexPosID,t.geometryBufferID),t.material.SetAttribute(t.aTexturePosID,t.textureBufferID),t.material.SetAttribute(t.aColorID,t.colorBufferID);const i=t.material.gl;i.useProgram(t.material.program),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,t.texture.GetNativeTexture()),Application.gl_multidraw.multiDrawArraysWEBGL(i.TRIANGLE_STRIP,t.indexes,0,t.trisCounts,0,t.tiles.length),i.useProgram(null),i.flush()}Reload(){super.Reload();for(let t=0;t<this.#s.length;t++)this.#s[t].SetMaterial(this.material)}ForceMeshUpdate(){this.#t||(this.grid=this.GetComponentInParent("Grid")),this.#l=Vector2.Add(this.grid.cellSize,this.grid.cellGap);for(let t=0;t<this.#s.length;t++)this.#s[t].SetMaterial(this.material),this.#s[t].UpdateMesh();this.#e=!1,this.#t=!0,this.#m(),super.ForceMeshUpdate()}RecalcBounds(){if(null==this.grid||null==this.#n&&null==this.#d)return void super.RecalcBounds();const t=new Bounds;t.SetMinMax(this.grid.CellToWorld(Vector2.Add(this.#n,new Vector2(-.5,-.5))),this.grid.CellToWorld(Vector2.Add(this.#d,new Vector2(.5,.5)))),this.#a=t,super.RecalcBounds()}Render(){if(this.#l.Equals(Vector2.Add(this.grid.cellSize,this.grid.cellGap))||this.ForceMeshUpdate(),this.#h.Equals(this.color)||this.#m(),null==this.#u){if(this.#s.length>0)for(let t=0;t<this.#s.length;t++)this.#p(this.#s[t]);this.#i&&this.#g()}else this.#f()}#f(){const t=this.material.gl,e=this.renderMatrix;this.material.SetMatrix(this.uMatrixID,e.matrix[0][0],e.matrix[0][1],e.matrix[0][2],e.matrix[1][0],e.matrix[1][1],e.matrix[1][2],e.matrix[2][0],e.matrix[2][1],e.matrix[2][2]),this.material.SetAttribute(this.aVertexPosID,this.geometryBufferID),this.material.SetAttribute(this.aTexturePosID,this.textureBufferID),this.material.SetAttribute(this.aColorID,this.colorBufferID),t.useProgram(this.material.program),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.#u.texture.GetNativeTexture()),t.drawArrays(t.TRIANGLE_STRIP,0,5),t.useProgram(null)}GetTile(t){return this.#r.find((e=>e.position.Equals(t)))}async AddTile(t){const e=this.GetTile(t.position);if(null!=e){const i=this.#r.indexOf(e);if(e.spriteID===t.spriteID)return i;this.RemoveTile(i)}else null!=this.#n&&null!=this.#d?(this.#n=new Vector2(Math.min(this.#n.x,t.position.x),Math.min(this.#n.y,t.position.y)),this.#d=new Vector2(Math.max(this.#d.x,t.position.x),Math.max(this.#d.y,t.position.y))):(this.#n=new Vector2(t.position.x,t.position.y),this.#d=new Vector2(t.position.x,t.position.y));this.#r.push(t);let i=TilePalette.Find(t.palette);null==i&&(await TilePalette.Load(t.palette),i=TilePalette.Find(t.palette)),t.sprite=i.sprites.find((e=>e.id===t.spriteID)).sprite;let r=this.#s.find((e=>e.texture===t.sprite.texture));const s=null==r;return s&&(r=new this.#c,r.texture=t.sprite.texture,r.color=[this.color.r,this.color.g,this.color.b,this.color.a],r.parent=this,this.#s.push(r)),this.#t?(s?(r.tiles.push(t),r.SetMaterial(this.material),r.UpdateMesh()):r.Add(t),this.RecalcBounds()):r.tiles.push(t),this.#r.length}RemoveTile(t){if(t<0||t>=this.#r.length)return;const e=this.#r[t];this.#r.splice(t,1);for(let t=0;t<this.#r.length;t++){const e=this.#r[t].position;0!==t?(this.#n=new Vector2(Math.min(this.#n.x,e.x),Math.min(this.#n.y,e.y)),this.#d=new Vector2(Math.max(this.#d.x,e.x),Math.max(this.#d.y,e.y))):(this.#n=new Vector2(e.x,e.y),this.#d=new Vector2(e.x,e.y))}0===this.#r.length&&(this.#n=null,this.#d=null,this.#a=new Bounds(new Vector2(NaN,NaN))),this.RecalcBounds();const i=this.#s.find((t=>t.texture===e.sprite.texture));if(this.#t)i.Remove(e);else{const t=i.tiles.indexOf(e);i.tiles.splice(t,1)}0===i.tiles.length&&this.#s.splice(this.#s.indexOf(i),1)}RemoveTileByPosition(t){const e=this.GetTile(t);null!=e&&this.RemoveTile(this.#r.indexOf(e))}async#g(){this.#i=!1;const t=this.mergeResolution,e=document.createElement("canvas");e.width=(this.#d.x-this.#n.x+1)*this.#l.x*t,e.height=(this.#d.y-this.#n.y+1)*this.#l.y*t,e.style.imageRendering="pixelated";const i=e.getContext("2d");for(let e=0;e<this.#r.length;e++){const r=this.#r[e].sprite,s=r.texture,l=r.rect,a=new Vector2((this.#r[e].position.x-this.#n.x)*this.#l.x,(this.#r[e].position.y-this.#d.y)*this.#l.y),o=new Vector2(.5*l.width/r.pixelPerUnit-.5*this.#l.x,.5*l.height/r.pixelPerUnit-.5*this.#l.y),h=Vector2.Scale(Vector2.Add(Vector2.Scale(r.pivot,-2),1),new Vector2(.5*l.width,.5*l.height));i.imageSmoothingEnabled=!1,i.drawImage(s.img,l.x,l.y,l.width,l.height,(a.x-o.x)*t+h.x,(-a.y-o.y)*t+h.y,l.width*t/r.pixelPerUnit,l.height*t/r.pixelPerUnit)}const r=new Texture(e.toDataURL("image/png"),"");await r.Load(),e.width=0,e.height=0,i.reset();const s=r.sprites[0],l=s.vertices,a=s.triangles;let o=[];for(let t=0;t<a.length;t++){const e=l[a[t]];o.push(e.x,e.y)}const h=r.width,n=r.height,d=h/t,u=n/t;this.material.SetBuffer(this.geometryBufferID,o),this.material.SetBuffer(this.textureBufferID,o),this.#o=Matrix3x3.TRS(Vector2.Add(new Vector2(-.5*d,-.5*u),Vector2.Scale(Vector2.Add(this.#n,this.#d),Vector2.Scale(this.#l,new Vector2(.5,-.5)))),0,Vector2.Scale(h>n?new Vector2(1,n/h):new Vector2(h/n,1),h>n?d:u)),this.#u=s,this.#m()}Merge(){this.Unmerge(),this.#i=!0}Unmerge(){this.mergedRendering&&(this.#u.texture.Unload(),this.#u=null,this.#o=Matrix3x3.identity)}Duplicate(){const t=new Tilemap(this.material.Duplicate());for(let e=0;e<this.#r.length;e++)t.AddTile(this.#r[e].Duplicate());return this.mergedRendering&&t.Merge(),t.color=this.color.Duplicate(),t.sortingLayer=this.sortingLayer,t.sortingOrder=this.sortingOrder,t.mergeResolution=this.mergeResolution,t}}