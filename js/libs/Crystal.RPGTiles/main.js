class TilePalette{static#t=!1;static#e=[];static#s=[];name="";sprites=[];static get isLoaded(){return this.#t}static async Set(){if(this.#t)return;const t=await fetch("data/tilepalettes.json");this.#e=await t.json(),this.#t=!0}static async Load(t){const e=this.#e.find((e=>e.name===t)),s=new TilePalette;s.name=t;const a=[],unloadCall=()=>{for(let t=0;t<a.length;t++)a[t].onUnload.Remove(unloadCall);this.Unload(t)};for(let t=0;t<e.textures.length;t++){if(0===e.textures.sprites?.length)continue;const i=Resources.Find(e.textures[t].src);i.onUnload.Add(unloadCall),a.push(i),s.sprites.push(...e.textures[t].sprites.map((t=>{const e=null!=t.name?i.sprites.find((e=>e.name===t.name)):i.sprites[t.index??0];return{id:t.id,sprite:e.Duplicate()}})))}this.#s.push(s)}static Unload(t){const e=this.Find(t);this.#s.splice(this.#s.indexOf(e),1)}static UnloadAll(){this.#s=[]}static Find(t){return this.#s.find((e=>e.name===t))}}TilePalette.Set();class Tile{palette="";spriteID=0;position=Vector2.zero;sprite=null;constructor(t,e,i){this.palette=t,this.spriteID=e??0,this.position=i??Vector2.zero}}class Tilemap extends Renderer{#t=!1;#e=!0;#r=[];#i=[];#s=Vector2.zero;#l=new Bounds(new Vector2(NaN,NaN));#o=null;#a=null;#h=null;grid=null;get meshChanged(){return this.#e}get bounds(){return new Bounds(this.#l.center,this.#l.size)}get localToWorldMatrix(){return this.grid.transform.localToWorldMatrix}#n=class{colorsUpdated=!1;arraysUpdated=!1;currentIndex=0;uMatrixID=0;geometryBufferID=0;textureBufferID=0;colorBufferID=0;aVertexPosID=0;aTexturePosID=0;aColorID=0;tiles=[];vertexArray=[];textureArray=[];color=[];colorArray=[];indexes=[];trisCounts=[];scaler=Vector2.zero;texture=null;material=null;parent=null;#d(t){const e=t.sprite.vertices,r=e[0],i=t.sprite.triangles,s=Vector2.Divide(Vector2.Subtract(this.parent.grid.CellToWorldUnscaled(new Vector2(t.position.x,-t.position.y)),Vector2.Divide(Vector2.Scale(new Vector2(t.sprite.rect.width,t.sprite.rect.height),t.sprite.pivot),this.texture.pixelPerUnit)),this.scaler);let l=[],o=[];for(let t=0;t<i.length;t++){const a=e[i[t]],h=2*t;l[h]=a.x-r.x+s.x,l[h+1]=a.y-r.y+s.y,o[h]=a.x,o[h+1]=a.y}return{vertexArray:l,textureArray:o,trisCount:i.length}}SetMaterial(t){this.material?.Unload(),this.material=t.Duplicate(),this.material.SetSampler2D("uSampler",0),this.uMatrixID=this.material.GetPropertyNameID("uMatrix"),this.geometryBufferID=this.material.AddBuffer("geometry",null,2),this.textureBufferID=this.material.AddBuffer("texture",null,2),this.colorBufferID=this.material.AddBuffer("color",null,4),this.aVertexPosID=this.material.GetAttributeNameID("aVertexPos"),this.aTexturePosID=this.material.GetAttributeNameID("aTexturePos"),this.aColorID=this.material.GetAttributeNameID("aColor")}SetColors(t){this.color=t,this.colorArray=[];for(let e=0;e<this.tiles.length;e++)this.colorArray.push(...t,...t,...t,...t,...t,...t);this.colorsUpdated=!0}UpdateMesh(){const t=this.texture.pixelPerUnit,e=this.texture.width,r=this.texture.height,i=e/t,s=r/t;this.scaler=Vector2.Scale(e>r?new Vector2(1,r/e):new Vector2(e/r,1),e>r?i:s),this.currentIndex=0,this.vertexArray=[],this.textureArray=[],this.trisCounts=[],this.indexes=[];for(let t=0;t<this.tiles.length;t++){const e=this.#d(this.tiles[t]);this.vertexArray.push(...e.vertexArray),this.textureArray.push(...e.textureArray),this.trisCounts.push(e.trisCount-1),this.indexes.push(this.currentIndex),this.currentIndex+=e.trisCount}this.arraysUpdated=!0,this.SetColors(this.color)}Add(t){this.tiles.push(t);const e=this.#d(t);this.vertexArray.push(...e.vertexArray),this.textureArray.push(...e.textureArray),this.trisCounts.push(e.trisCount-1),this.indexes.push(this.currentIndex),this.currentIndex+=e.trisCount,this.colorArray.push(...this.color,...this.color,...this.color,...this.color,...this.color,...this.color),this.arraysUpdated=!0,this.colorsUpdated=!0}Remove(t){const e=this.tiles.indexOf(t),r=12*e;this.tiles.splice(e,1),this.vertexArray.splice(r,12),this.textureArray.splice(r,12),this.trisCounts.splice(e,1),this.indexes.pop(),this.currentIndex-=t.sprite.triangles.length,this.colorArray.splice(0,24),this.arraysUpdated=!0,this.colorsUpdated=!0}};constructor(t){super(t),this.Reload()}#u(){this.#o=this.color.Duplicate();const t=[this.color.r,this.color.g,this.color.b,this.color.a];for(let e=0;e<this.#i.length;e++)this.#i[e].SetColors(t)}#c(t){t.colorsUpdated&&(t.material.SetBuffer(t.colorBufferID,t.colorArray),t.colorsUpdated=!1),t.arraysUpdated&&(t.material.SetBuffer(t.geometryBufferID,t.vertexArray),t.material.SetBuffer(t.textureBufferID,t.textureArray),t.arraysUpdated=!1);const e=Matrix3x3.Multiply(this.renderMatrix,Matrix3x3.Scale(t.scaler));t.material.SetMatrix(t.uMatrixID,e.matrix[0][0],e.matrix[0][1],e.matrix[0][2],e.matrix[1][0],e.matrix[1][1],e.matrix[1][2],e.matrix[2][0],e.matrix[2][1],e.matrix[2][2]),t.material.SetAttribute(t.aVertexPosID,t.geometryBufferID),t.material.SetAttribute(t.aTexturePosID,t.textureBufferID),t.material.SetAttribute(t.aColorID,t.colorBufferID);const r=t.material.gl;r.useProgram(t.material.program),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,t.texture.GetNativeTexture()),Application.gl_multidraw.multiDrawArraysWEBGL(r.TRIANGLE_STRIP,t.indexes,0,t.trisCounts,0,t.tiles.length),r.useProgram(null),r.flush()}Reload(){super.Reload();for(let t=0;t<this.#i.length;t++)this.#i[t].SetMaterial(this.material)}ForceMeshUpdate(){this.#t||(this.grid=this.GetComponentInParent("Grid")),this.#s=Vector2.Add(this.grid.cellSize,this.grid.cellGap);for(let t=0;t<this.#i.length;t++)this.#i[t].SetMaterial(this.material),this.#i[t].UpdateMesh();this.#e=!1,this.#t=!0,this.#u(),super.ForceMeshUpdate()}RecalcBounds(){if(null==this.#a&&null==this.#h)return void super.RecalcBounds();const t=new Bounds;t.SetMinMax(this.grid.CellToWorld(Vector2.Add(this.#a,new Vector2(-.5,-.5))),this.grid.CellToWorld(Vector2.Add(this.#h,new Vector2(.5,.5)))),this.#l=t,super.RecalcBounds()}Render(){if(this.#s.Equals(Vector2.Add(this.grid.cellSize,this.grid.cellGap))||this.ForceMeshUpdate(),this.#o.Equals(this.color)||this.#u(),0!==this.#i.length)for(let t=0;t<this.#i.length;t++)this.#c(this.#i[t])}GetTile(t){return this.#r.find((e=>e.position.Equals(t)))}async AddTile(t){const e=this.GetTile(t.position);if(null!=e){const r=this.#r.indexOf(e);if(e.spriteID===t.spriteID)return r;this.RemoveTile(r)}else null!=this.#a&&null!=this.#h?(this.#a=new Vector2(Math.min(this.#a.x,t.position.x),Math.min(this.#a.y,t.position.y)),this.#h=new Vector2(Math.max(this.#h.x,t.position.x),Math.max(this.#h.y,t.position.y))):(this.#a=new Vector2(t.position.x,t.position.y),this.#h=new Vector2(t.position.x,t.position.y));this.#r.push(t);let r=TilePalette.Find(t.palette);null==r&&(await TilePalette.Load(t.palette),r=TilePalette.Find(t.palette)),t.sprite=r.sprites.find((e=>e.id===t.spriteID)).sprite;let i=this.#i.find((e=>e.texture===t.sprite.texture));const s=null==i;return s&&(i=new this.#n,i.texture=t.sprite.texture,i.color=[this.color.r,this.color.g,this.color.b,this.color.a],i.parent=this,this.#i.push(i)),this.#t?(s?(i.tiles.push(t),i.SetMaterial(this.material),i.UpdateMesh()):i.Add(t),this.RecalcBounds()):i.tiles.push(t),this.#r.length}RemoveTile(t){if(t<0||t>=this.#r.length)return;const e=this.#r[t];this.#r.splice(t,1);for(let t=0;t<this.#r.length;t++){const e=this.#r[t].position;0!==t?(this.#a=new Vector2(Math.min(this.#a.x,e.x),Math.min(this.#a.y,e.y)),this.#h=new Vector2(Math.max(this.#h.x,e.x),Math.max(this.#h.y,e.y))):(this.#a=new Vector2(e.x,e.y),this.#h=new Vector2(e.x,e.y))}0===this.#r.length&&(this.#a=null,this.#h=null,this.#l=new Bounds(new Vector2(NaN,NaN))),this.RecalcBounds();const r=this.#i.find((t=>t.texture===e.sprite.texture));if(this.#t)r.Remove(e);else{const t=r.tiles.indexOf(e);r.tiles.splice(t,1)}0===r.tiles.length&&this.#i.splice(this.#i.indexOf(r),1)}RemoveTileByPosition(t){const e=this.GetTile(t);null!=e&&this.RemoveTile(this.#r.indexOf(e))}}